# Java 面试题总结

### JVM
##### 1.Java 内存空间结构
      *  栈：线程私有，每进入一个方法会创建一个栈帧（栈帧存放方法的局部变量，常量池指针，操作数栈,
      在没有逃逸的情况下，小对象可直接栈上分配）通过-Xss128k参数来分配每个线程的堆栈空间大小
      *  堆：存放数组，对象，分eden区，old区，通过-Xmx2G -Xms分配堆内存大小,-Xmn eden区大小
      *  方法区（永久区） 保存装载的类信息（字段、方法信息，方法字节码)
      *  本地方法区           

##### 2.Java 对象的创建过程（JVM角度）
        要初始化一个对象，首先要加载该对象所对应的class文件，该文件的数据会被加载到永久代，并创建
      个底层的instanceClass对象代表改该class，再为将要初始化的对象分配内存空间，优先在线程私有
      空间上分配（栈上分配），如果分配空间不足或者存在逃逸情况，再到eden区分配。

##### 3.Java类加载器&双亲委派机制
        新建一个对象时，JVM需要将对应的字节码信息加载到内存中，这些字节码的元信息来自classpath下
      或者网络，经过一些处理后变成字节码加载到内存中。

      类加载器类别及加载区域
      BootStrap 类加载器   /lib/rt.jar
      ExtClassLoader     /lib/ext/*.jar
      AppClassLoader     classpath下面

      双亲委派机制：
        当类加载器接受到类加载请求时，首先将加载请求任务委托给父类加载器，如果父类加载器加载成功
      就返回，否则只有父类加载器加载不了，才会自己去加载。
      
      好处：避免内存中出现多份同样的字节码信息，各个加载器各司其职。

##### 4.gc算法及种类
       引用计数法  (无法解决循环引用问题)
       ----------可达性分析，从栈，永久区，本地方法区的对象作为ROOT对象，进行可达性分析，
                 不可达的对象即可标记
       标记清除法
       标记压缩法  处理垃圾碎片，让内存空间连续
       复制算法   年轻代，存活对象较少的情况下

#####  5.垃圾收集器种类
        串行收集器  -XX:+UseSerialGC GC收集的时候，应用程序暂停（stop the world）
                  采用的回收算法 新生代复制算法，老年代标记压缩算法
        并行收集器  -XX:+UseParNewGC 新生代并行，老年代串行 
                  -XX:ParallelGCThreads 指定并行线程数量
        CMS收集器   Concurrent Mark Sweep 并发标记清除  -XX：+UseConcMarkSweepGC

                   过程：初始标记、并发标记（和用户线程一起）
                        重新标记（由于并发标记时，用户线程依然运行，因此在正式清理前，
                        再做修正）
                        并发清除（和用户线程一起，基于标记结果，直接清理对象）
                   优缺点：尽可能降低停顿（Stop the World时间）
                         影响系统整体吞吐量和性能（比如用户线程运行过程中，分一半CPU去做GC
                         系统性能在GC阶段，反应速度下降一半）
                         清理不彻底 ，在清理阶段和用户线程一起运行，对于新产生的垃圾，无法清理
                         同时不能识别到空间快满的临界点。

##### 6.内存溢出，排错
        jstat -gcutil [PID]  查询GC频率是否正常，查看GC是否能回收掉垃圾
        jamp -histo:live [PID] 触发FULL GC
        jatck [PID] 查看线程堆栈信息
        jamp -dump  dump快照，利用VisialVM进行分析

###  分布式框架

##### 1.一致Hash算法（redis，memcache节点）
        普通Hash算法缺点: n个节点机器hash(object)/n ,当需要增加节点时hash(object)n+1
                       导致所有大量节点请求miss,因为Object的hash值被全部重新定位了。 
        一致Hash原理及解决问题:解决了普通余数Hash算法伸缩性差的问题，可以保证在上线、下线服务器的
                           情况下尽量有多的请求命中原来路由到的服务器。
        原理：环形Hash空间，hash(object) <= hash(node) 的最小hash(node) 节点上，这样当
             增减节点时只有当前节点的请求会miss
        github:

##### 2.zookeeper选举算法
        关键属性：
               zxid(leader版本同步信息)
               sid（机器ID）
        选举状态：Looking 竞选状态
                Following 随从状态
                Observing 观察状态
                Leading   领导状态
        选举过程（默认采用投票数大于参与选举的半数参与者则胜出）
        1,2,3,4,5 台机器依次启动
        1 启动，投票自身，进入looking状态
        2 启动，投票自身，由于2比1的sid大获胜，获取到1的投票，由于投票数还没大于半数
          进入looking状态。
        3 启动 投票自身，与1,2交换信息，由于3的sid大于1,2的，获取到1,2的投票，
          这个时候获取的投票数大于半数参与者，所以3成为leading,zxid增加
        4 启动，投票自身，由于4的zxid小于3 成为3的小弟

##### 3.zookeeper节点设置奇偶数问题
        推荐奇数个节点

        无法选出leader的情况：1.整个集群就2台机器  2.超过半数机器挂掉
        eg.集群有5个节点，最多允许2个节点挂掉，假如有3个节点挂掉，那么整个集群的选举结果不会满足
           获得超过半数投票的条件
           集群有6个节点，最多也只允许2个节点挂掉，同理整个集群的选举结果不会满足获得超过半数投票
           的条件

##### 4.RocketMQ 优点，选用的理由
        高性能(commitLog,queue之存储log的地址及Hash(tag))
        高可靠（集群模式，多master,支持同步刷盘，异步刷盘）
        高实时（当queue 没有消息堆积时，毫秒级消费）
        分布式（可扩展consumerGroup,producerGroup）

        支持顺序消费
        事务型消息

        各消息中间件对比：
            Kafaka 擅长日志处理，支持海量消息数据且性能没有明显下降，但消息可能存在丢失
            rabbitMq erlang语言实现，不好扩展，不利于二次开发
            activeMq 实现很多协议，不够轻量级

        单Master:风险很大，一旦宕机，导致服务不可用
        多Master:一个集群无Slave,单个Master宕机或者重启维护对应用无影响。即使机器宕机不可恢复
                 消息几乎也不会丢失（异步刷盘少量数据丢失，同步刷盘一条不丢）而且性能方面最高
                 单机宕机期间，这台机器上未被消费的消息在恢复之前不可订阅，消息实时性会受到影响。

        多Master多Slave,异步复制：HA采用异步复制方式，主备有短暂延迟，毫秒级。单机宕机，消息实
                               时性不会受到影响，消费者仍可以从Slave消费。
        多Master多Slave,同步双写：主备都写成功，向应用返回成功。消息无延迟服务可用性和消息可用性
        非常高。但是性能低


##### 5.redis实现消息队列及注册中心
        redis内部结构list,可实现阻塞队列。但redis不擅长消息队列，消息持久化，消息消费失败等问题
        注册中心：redis的发布订阅模式

##### 6.dubbo原理
        基本组件：
        container 服务容器负责启动加载服务
        provider  服务提供者向注册中心注册提供服务
        consumer  服务消费者向注册中心订阅所需服务
        register  注册中心返回提供者地址列表给消费者，地址如有变化，注册中心基于长连接推送变更
                  数据给消费者，服务消费者从提供的地址列表中基于负载均衡算法选择一个地址进行调用
                  如果调用失败基于集群容错机制调用下一台或者直接返回。
        moniter   服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据
                  到监控中心。


##### 7.RPC原理
        RPC远程调用问题：
        如何封装底层网络细节，像调用本地服务一样调用远程服务
        参数格式
        IO模型
        序列化方式
        requestID

        调用过程简述：
        1.client一个线程调用远程接口，生成一个唯一的ID（比如随机字符串UUID），dubbo使用
          AtomicLong从0开始累积计数
        2.将打包的方法调用信息（如调用接口的名称，方法名称，参数列表）和处理结果的回调对象
          callback全部封装在一起，组成一个对象object
        3.向专门存放调用信息的全局ConsurrentHashMap里put(ID,Object)
        4.将ID和打包的方法调用信息封装一个对象connRequest,使用IOSession.write 异步发送出去
        5.当前线程再使用callback的get()方法试图获取远程返回的结果，在get()内部，则使用sychronized获取回调对象的callback锁，再检测是否已经获取到结果，如果没有
        ,wait()等待。
        6.服务端接收到请求并处理后，将结果（包含请求唯一ID）发送给客户端，客户端socket连接上专门
          监听消息线程收到消息，分析结果，取到ID再从前面的ConcurrentHashMap里面get(ID)，从而找到callback，将方法调用结果设置到callback对象里。再从前面的ConcurrentHashMap里面get(ID)，从而找到callback，将方法调用结果设置到callback对象里。
        7.监听线程接着使用synchronized获取回调对象callback的锁（因为前面调用过wait()
          ，那个线程已释放callback的锁了），再notifyAll()
          ，唤醒前面处于等待状态的线程继续执行（callback的get()
          方法继续执行就能拿到调用结果了），至此，整个过程结束。

#####  8.dubbo负载均衡策略&集群容错
         Random       基于权重随机
         RoundRobin   基于权重轮询
         LeastActive  最少活跃数
         Consistent Hash 一致Hash

        Failover   出错重试其他机器 可设置reties = '2'(不含第一次)
        Failover   出错重试其他机器 可设置reties = '2'(不含第一次)
        Failfast   出错立即返回错误，通常用于幂等接口
        Failsafe   出错安全 直接忽略  通常用于日志性的操作
        FailBack   失败记录日志，定时重发 用于消息
        Forking    同时并行调用多个服务，只要一个成功返回。一般用于实时性要求比较高的查询服务
        Broadcast 广播调用所有服务 通常用于更新缓存等操作


















