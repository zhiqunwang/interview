# Java 面试题总结

### JVM
##### 1.Java 内存空间结构
      *  栈：线程私有，每进入一个方法会创建一个栈帧（栈帧存放方法的局部变量，常量池指针，操作数栈,
      在没有逃逸的情况下，小对象可直接栈上分配）通过-Xss128k参数来分配每个线程的堆栈空间大小
      *  堆：存放数组，对象，分eden区，old区，通过-Xmx2G -Xms分配堆内存大小,-Xmn eden区大小
      *  方法区（永久区） 保存装载的类信息（字段、方法信息，方法字节码)
      *  本地方法区           

##### 2.Java 对象的创建过程（JVM角度）
        要初始化一个对象，首先要加载该对象所对应的class文件，该文件的数据会被加载到永久代，并创建
      个底层的instanceClass对象代表改该class，再为将要初始化的对象分配内存空间，优先在线程私有
      空间上分配（栈上分配），如果分配空间不足或者存在逃逸情况，再到eden区分配。

##### 3.Java类加载器&双亲委派机制
        新建一个对象时，JVM需要将对应的字节码信息加载到内存中，这些字节码的元信息来自classpath下
      或者网络，经过一些处理后变成字节码加载到内存中。

      类加载器类别及加载区域
      BootStrap 类加载器   /lib/rt.jar
      ExtClassLoader     /lib/ext/*.jar
      AppClassLoader     classpath下面

      双亲委派机制：
        当类加载器接受到类加载请求时，首先将加载请求任务委托给父类加载器，如果父类加载器加载成功
      就返回，否则只有父类加载器加载不了，才会自己去加载。
      
      好处：避免内存中出现多份同样的字节码信息，各个加载器各司其职。

##### 4.gc算法及种类
       引用计数法  (无法解决循环引用问题)
       ----------可达性分析，从栈，永久区，本地方法区的对象作为ROOT对象，进行可达性分析，
                 不可达的对象即可标记
       标记清除法
       标记压缩法  处理垃圾碎片，让内存空间连续
       复制算法   年轻代，存活对象较少的情况下

#####  5.垃圾收集器种类
        串行收集器  -XX:+UseSerialGC GC收集的时候，应用程序暂停（stop the world）
                  采用的回收算法 新生代复制算法，老年代标记压缩算法
        并行收集器  -XX:+UseParNewGC 新生代并行，老年代串行 
                  -XX:ParallelGCThreads 指定并行线程数量
        CMS收集器   Concurrent Mark Sweep 并发标记清除  -XX：+UseConcMarkSweepGC

                   过程：初始标记、并发标记（和用户线程一起）
                        重新标记（由于并发标记时，用户线程依然运行，因此在正式清理前，
                        再做修正）
                        并发清除（和用户线程一起，基于标记结果，直接清理对象）
                   优缺点：尽可能降低停顿（Stop the World时间）
                         影响系统整体吞吐量和性能（比如用户线程运行过程中，分一半CPU去做GC
                         系统性能在GC阶段，反应速度下降一半）
                         清理不彻底 ，在清理阶段和用户线程一起运行，对于新产生的垃圾，无法清理
                         同时不能识别到空间快满的临界点。

##### 6.内存溢出，排错
        jstat -gcutil [PID]  查询GC频率是否正常，查看GC是否能回收掉垃圾
        jamp -histo:live [PID] 触发FULL GC
        jatck [PID] 查看线程堆栈信息
        jamp -dump  dump快照，利用VisialVM进行分析

###  分布式框架

##### 1.一致Hash算法（redis，memcache节点）
        普通Hash算法缺点: n个节点机器hash(object)/n ,当需要增加节点时hash(object)n+1
                       导致所有大量节点请求miss,因为Object的hash值被全部重新定位了。 
        一致Hash原理及解决问题:解决了普通余数Hash算法伸缩性差的问题，可以保证在上线、下线服务器的
                           情况下尽量有多的请求命中原来路由到的服务器。
        原理：环形Hash空间，hash(object) <= hash(node) 的最小hash(node) 节点上，这样当
             增减节点时只有当前节点的请求会miss
        github:

##### 2.zookeeper选举算法
        关键属性：
               zxid(leader版本同步信息)
               sid（机器ID）
        选举状态：Looking 竞选状态
                Following 随从状态
                Observing 观察状态
                Leading   领导状态
        选举过程（默认采用投票数大于参与选举的半数参与者则胜出）
        1,2,3,4,5 台机器依次启动
        1 启动，投票自身，进入looking状态
        2 启动，投票自身，由于2比1的sid大获胜，获取到1的投票，由于投票数还没大于半数
          进入looking状态。
        3 启动 投票自身，与1,2交换信息，由于3的sid大于1,2的，获取到1,2的投票，
          这个时候获取的投票数大于半数参与者，所以3成为leading,zxid增加
        4 启动，投票自身，由于4的zxid小于3 成为3的小弟

##### 3.zookeeper节点设置奇偶数问题
        













